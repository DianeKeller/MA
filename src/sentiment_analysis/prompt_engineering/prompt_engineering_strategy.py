"""
prompt_engineering_strategy.py
-------------------------------
Version 1.0, updated on 2025-05-01

"""

from abc import ABC, abstractmethod
from typing import List, Tuple, Dict

from pandas import DataFrame

from src.data_structures.history import History
from src.logging_mixin import LoggingMixin
from src.sentiment_analysis.prompt_engineering.prompt_generator_factory \
    import get_prompt_generator
from src.sentiment_analysis.prompt_engineering.prompt_ingredients_mixin \
    import PromptIngredientsMixin
from src.sentiment_analysis.prompt_engineering.prompts_generator import (
    PromptsGenerator
)
from src.sentiment_analysis.retrieval.custom_exceptions import (
    CriticalException
)
from src.sentiment_analysis.sentiment_analysis_config import (
    SentimentAnalysisConfig
)
from src.serialization.data_serialization_mixin import DataSerializationMixin
from src.utils.data_utils import is_none_or_empty
from src.utils.list_utils import to_dict_with_str_keys
from type_aliases import PromptsDictType, PromptIngredientsType


class PromptEngineeringStrategy(
    ABC,
    DataSerializationMixin,
    LoggingMixin,
    PromptIngredientsMixin
):
    """
    PromptEngineeringStrategy class.

    Base class for PromptEngineeringStrategy subclasses.

    Class for handling prompt engineering tasks for sentiment retrieval.

    Attributes
    ----------

    file_name : str
        The file name for the serialization of the queries.

    file_type : str
        The file type used for serialization, defaulting to 'txt'.


    """

    def __init__(self, target_n_prompts: int = 0):
        """
        Initializes the present class with the given parameters.

        Initializes the present class with the target number of prompts to
        generate and the file name for serialization of the queries.

        """

        self._data = None

        self._discarded_prompts = None
        self._prompts = None
        self._prompt_ingredients_sets = None

        # Default value:
        self._prompt_generating_strategy_nr = 1

        # Configs used in this class
        self.config = SentimentAnalysisConfig()

        # Update the target_n_prompts value and other settings in the
        # configuration that are specific for prompt engineering.
        self._set_prompt_engineering_config(target_n_prompts)

        # Set file type and name for the serialization of prompt engineering
        # results.
        self._set_file_properties()

        self.prompts_generator = PromptsGenerator(
            self.prompt_ingredients,
            self.prompt_generating_strategy_nr
        )

    # region --- Properties

    @property
    @abstractmethod
    def prompt_generating_strategy_nr(self) \
            -> int:
        """
        Returns the number of the prompt generating strategy to use.

        Returns the number of the prompt generating strategy to use for the
        generation of a prompt.

        Returns
        -------
        int
            The number of the prompt generating strategy to use.

        Raises
        ------
        NotImplementedError
            If the concrete stategy does not implement this abstract property.

        """

        raise NotImplementedError

    @property
    def prompts(self) \
            -> PromptsDictType:
        """
        Returns the prompts generated by propmpt engineering.

        Returns the prompts property, if it is set. Otherwise,
        tries to load prompts from disk. If this fails, tries to
        generate new prompts. If this also fails to set the
        prompts property, a CriticalException is raised.

        Returns
        -------
        PromptsDictType
            A Dictionary with the prompts where the keys are
            consecutive variant numbers starting from 1 and the values are
            dictionaries where the keys are position labels and the values
            are the texts to insert at the indicated positions.

        Raises
        ------
        CriticalException
            If the method fails to find prompts in the prompts
            property or on disk, and also fails to generate new variants.

        """

        if is_none_or_empty(self._prompts):
            self._set_prompts()

            if is_none_or_empty(self._prompts):
                raise CriticalException(
                    self.logger,
                    "No prompts could be found or generated! "
                    "Cannot proceed."
                )

        return self._prompts

    @prompts.setter
    def prompts(self, prompts: PromptsDictType) \
            -> None:
        """
        Sets the prompts.

        Parameters
        ----------
        prompts
            A Dictionary with generated prompts where the keys are
            consecutive variant numbers starting from 1 and the values are
            dictionaries where the keys are position labels and the values
            are the texts to insert at the indicated positions.

        """

        if is_none_or_empty(prompts):
            raise CriticalException(
                self.logger,
                "No prompts given!"
            )

        self._prompts = prompts

    @property
    def discarded_prompts(self) \
            -> PromptsDictType:
        """
        Returns the prompts discarded by propmpt engineering.

        Returns the discardedprompts property, if it is set. Otherwise,
        tries to load discarded prompts from disk. If this fails, the discarded
        prompts property is set to an empty dictionary.

        Returns
        -------
        PromptsDictType
           A Dictionary with the discarded prompts where the keys are
           consecutive variant numbers starting from 1 and the values are
           dictionaries where the keys are position labels and the values
           are the texts to insert at the indicated positions.

        """

        if is_none_or_empty(self._discarded_prompts):
            self._set_discarded_prompts()

        return self._discarded_prompts

    @discarded_prompts.setter
    def discarded_prompts(self, prompts: PromptsDictType) \
            -> None:
        """
        Sets the discarded prompts.

        Parameters
        ----------
        prompts : PromptsDictType
           A Dictionary with discarded prompts where the keys are
           consecutive variant numbers starting from 1 and the values are
           dictionaries where the keys are position labels and the values
           are the texts to insert at the indicated positions.

        """

        self._discarded_prompts = prompts

    @property
    def data(self) \
            -> PromptsDictType:
        """
        Gets the data.
        """

        return self._data

    @data.setter
    def data(self, data: PromptsDictType) \
            -> None:
        """
        Sets the data.
        """

        self._data = data

    @property
    @abstractmethod
    def prompt_ingredients(self) \
            -> PromptIngredientsType:
        """
        Returns the prompt ingredients used in the current strategy.

        Returns
        -------
        PromptIngredientsType
            A dictionary where the keys are prompt ingredients categories
            and the values are lists of possible values the categories can
            have.

        Raises
        ------
        NotImplementedError
            If the concrete stategy does not implement this abstract method.

        Notes
        -----
        The prompt ingredients can be identical with the all_ingredients set
        in the PromptIngredientsMixin, a part of them or a different set of
        ingredients, depending on the concrete strategy. The property must
        therefore be implemented by the concrete strategy subclasses.

        """

        raise NotImplementedError

    @property
    def prompt_ingredients_sets(self) \
            -> PromptsDictType:
        """
        Returns the prompt ingredients sets.

        If the prompt ingredients sets are not set,
        the _set_prompt_ingredients_sets method is called to retrieve them
        from the prompt ingriedients history loaded from disk, converting
        the history into a PromptsDictType format.

        """

        if is_none_or_empty(self._prompt_ingredients_sets):
            self._set_prompt_ingredients_sets()

        return self._prompt_ingredients_sets

    @prompt_ingredients_sets.setter
    def prompt_ingredients_sets(self, ingredients_sets: PromptsDictType) \
            -> None:
        """
        Sets the prompt ingredients sets.

        Parameters
        ----------
        ingredients_sets : PromptsDictType
            The ingredients sets to use for setting the prompt ingredients
            sets.

        """

        self._prompt_ingredients_sets = ingredients_sets

    @property
    def prompt_ingredients_history(self) \
            -> History:
        """
        Returns the prompt ingredients history.

        Default implementation. May be overridden by subclasses

        Returns
        -------
        History
           A History object containing data in a HistoryDataType format.

        Raises
        ------
        NotImplementedError
           If the concrete stategy does not implement this abstract method.

        """

        history = self.prompts_generator.prompt_ingredients_history

        if history.can_load():
            history.load()

        return history

    @property
    @abstractmethod
    def basic_ingredients(self) \
            -> PromptIngredientsType:
        """
        Returns the basic ingredients used in the current strategy.

        Returns
        -------
        PromptIngredientsType
            A dictionary where the keys are prompt ingredients categories
            and the values are lists of possible values the categories can
            have.

        Raises
        ------
        NotImplementedError
            If the concrete stategy does not implement this abstract method.

        """

        raise NotImplementedError

    @property
    @abstractmethod
    def basic_and_composed_ingredients(self) \
            -> List[Tuple[str, str]]:
        """
        Returns the basic ingredients used in the current strategy.

        Returns
        -------
        List[Tuple[str, str]]
            The list of tuples of basic and composed ingredients types.
            The first element of each tuple is a basic ingredient type and
            the second a composed ingredient type the basic ingredient
            type contributes to compose. A basic ingredient type can
            be used in various composed ingredients types and a composed
            ingredient type usually is composed of multiple basic
            ingredients types.

        Raises
        ------
        NotImplementedError
            If the concrete stategy does not implement this abstract method.

        """

        raise NotImplementedError

    # endregion --- Properties

    # region --- Public Methods

    @abstractmethod
    def add_query_cols(self, samples: DataFrame, chunk: PromptsDictType) \
            -> DataFrame:
        """
        Adds query columns to the provided samples.

        Abstract method to add query columns composed from the prompt parts
        in the provided chunk to the samples. This method must be
        implemented by the subclasses.

        Parameters
        ----------
        samples : DataFrame
            A samples DataFrame to which to add query columns.

        chunk : PromptsDictType
            Chunk of different prompts to use to create queries for each of
            the samples and add them in columns in the samples DataFrame.

        Returns
        -------
        DataFrame
            The provided samples DataFrame with the different query columns
            added.

        Raises
        ------
        NotImplementedError
            If the concrete stategy does not implement this abstract method.

        """

        raise NotImplementedError

    def decompose_prompt_part(self, category: str, prompt_part: str) \
            -> List[Tuple[str, str]]:
        """
        Decomposes a prompt part into its basic ingredients.

        Parameters
        ----------
        category : str
            The category of the prompt part to be decomposed.

        prompt_part : str
            The prompt part to be decomposed.

        Returns
        -------
        Dict[str, str]
            A dictionary containing the basic ingredients of the prompt part
            where the keys are the basic ingredient categories and the values
            are the basic ingredients.

        """

        prompt_generator = get_prompt_generator(
            {}, self.prompt_generating_strategy_nr
        )

        pattern = prompt_generator.get_prompt_part_generation_pattern(
            category
        )

        return self._match_pattern(prompt_part, pattern)

    # endregion --- Public Methods

    # region --- Abstract Methods

    def _generate_prompts(self) \
            -> None:
        """
        Generates and saves prompts.

        Default implementation for generating and saving prompts. May be
        overridden by subclasses.

        Dynamically computes a given number of prompts by systematically
        combining conceivable variants for different parts of a prompt.

        """

        self.prompts = self.prompts_generator.generate_prompts()

        self._save_prompts()

    # endregion --- Abstract Methods

    # region --- Protected Methods

    def _set_prompt_engineering_config(
            self,
            n_prompts: int
    ) -> None:
        """
        Adapt the SentimentAnalysisConfig parameters to the needs of prompt
        engineering.

        Parameters
        ----------
        n_prompts : int
            Number of prompts the target_n_prompts value is to be assigned.

       """

        # For finding errors in the implementation of the prompt
        # engineering loop, you may want to set the number of prompts to a
        # smaller number than in production. If you want to change the
        # target number of prompts, change the N_PROMPTS constant in the
        # concrete prompt engineering strategy.
        if n_prompts > 0:
            self.config.set('target_n_prompts', n_prompts)

            # Adapt the chunk size to the number of prompts if the latter is
            # smaller than the chunk size, otherwise the
            # 'parameters_not_empty' decorator of the '__init__' method of
            # the QueryColumnProcessor will raise a CriticalException:
            if n_prompts < self.config.get('chunk_size'):
                self.config.set('chunk_size', n_prompts)

    def _set_file_properties(self) \
            -> None:
        """
        Sets the file properties.

        Sets the file type and file name for saving and loading the
        prompts. The file name is composed using some of the sentiment
        analysis configuration settings (llm and version) and the number of
        the prompts.

        """

        config = self.config
        llm = config.get('llm')
        n_prompts = config.get('target_n_prompts')
        version = config.get('version')

        self.file_name = (f"{llm.name}_{n_prompts}_prompts_v"
                          f"_{version}")
        self.file_type = 'json'

    def _set_discarded_prompts_file_properties(self) \
            -> None:

        config = self.config
        llm = config.get('llm')
        version = config.get('version')

        self.file_name = (f"{llm.name}_invalid_prompts_v"
                          f"_{version}")
        self.file_type = 'json'

    def _save_prompts(self) \
            -> None:
        """
        Saves prompts locally on disk.

        Checks whether the number of prompts matches the expected number. If
        it does not, logs an informational message.

        Notes
        -----
        - To disable the Pylint message 'attribute-defined-outside-init', the
          corresponding code 'W0201' is used to avoid a 'line-too-long' error.

        """

        n_prompts = len(self.prompts)
        target_n_prompts = self.config.get('target_n_prompts')

        if n_prompts != target_n_prompts:
            msg = "Number of prompts is %d. Expected number was: %d" % (
                n_prompts, target_n_prompts)
            self._log(msg, "info")

        # The data property is provided by the DataSerializationMixin.
        self.data = self.prompts
        self.save()

    def _load_prompts(self) \
            -> None:
        """
        Loads prompts from disk.

        Returns
        -------
        PromptsDictType
            A Dictionary with the prompts where the keys are
            consecutive prompt numbers starting from 1 and the values are
            dictionaries where the keys are position labels and the values
            are the texts to insert at the indicated positions.

        """

        if self.can_load():
            self.load()
            self.prompts = self.data

    def _load_discarded_prompts(self) \
            -> None:
        """
        Loads discprompts from disk.

        """

        # Set the file properties to the discarded prompts file.
        self._set_discarded_prompts_file_properties()

        if self.can_load():
            self.load()
            # Convert list of dicts to PromptsDictType
            self.discarded_prompts = to_dict_with_str_keys(
                self.data, 1
            )

        # Reset the file_properties to the normal prompts file.
        self._set_file_properties()

    def _set_prompts(self) \
            -> None:
        """
        Sets the prompts property by loading or generating prompts.

        """

        self._load_prompts()

        if is_none_or_empty(self._prompts):
            self._generate_prompts()

    def _set_discarded_prompts(self) \
            -> None:
        """
        Sets the discarded prompts property by loading them from disk.

        If the discarded prompts file is not found, an empty dictionary is set.

        """

        self._load_discarded_prompts()

    def _set_prompt_ingredients_sets(self) \
            -> None:
        """
        Sets the prompt ingredients sets converting history data.

        Sets the prompt ingredients sets converting the history data loaded
        from disk into a PromptsDictType format.

        """

        self._prompt_ingredients_sets = to_dict_with_str_keys(
            self.prompt_ingredients_history.data, 1)

    def _match_pattern(
            self,
            prompt_part: str,
            pattern: List[Tuple[str, str]]
    ) -> List[Tuple[str, str]]:

        matches = []
        current_position = 0  # Track position in the string to analyze

        for pattern_type, value in pattern:
            if pattern_type == 'string':
                # Match a plain string in the pattern
                if prompt_part[current_position:].startswith(value):
                    current_position += len(value)

                else:
                    return []  # If the string doesn't match, return no matches

            elif pattern_type == 'ingredient':
                # Match an ingredient from the specified list
                found = False
                for ingredient in self.prompt_ingredients[value]:
                    if prompt_part[current_position:].startswith(
                            ingredient):
                        matches.append((value, ingredient))
                        current_position += len(ingredient)
                        found = True
                        break
                if not found:
                    return []  # If no ingredient matches, return no matches

        return matches

    # endregion --- Protected Methods
